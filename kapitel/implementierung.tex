\chapter{Implementierung der Web Applikation}
\section{Vorstellung der verwendeten Technologien}

\section{Behaviour Driven Development}

\textit{Behaviour Driven Development} ist eine Erweiterung des
\textit{Test Driven Development}, einer Methode aus dem Bereich der
\textit{Agilen Softwareentwicklung}. Ziel der Agilen
Softwareentwicklung ist es den klassischen Softwareentwicklungsprozess
schlanker und flexibler zu gestalten und sich mehr auf die zu
erreichenden Ziele und Anforderungen zu
fokussieren. Paarprogrammierung, ständige Refaktorisierungen des Codes
und testgetriebene Entwicklung sind einige der dabei verwendeten
Methoden \cite{wiki:agile}.

Behaviour Driven Development ist ein durch Dan North geprägter Begriff
und eine Erweiterung der Philosophie des Test Driven Developments
\cite{wiki:bdd}. Durch die Einführung eines gemeinsames Vokabluars
soll die Zusammenarbeit zwischen Programmieren und anderen
nicht-technischen Beteiligten an einem Softwareprojekt erhöht
werden. Das gemeinsame Vokabular wird dazu benutzt das Verhalten,
bzw. die Anforderungen der Software gemeinsam zu beschreiben. Diese
Anforderungen werden dann in Form von automatischen Tests vom
Programmierer implementiert. Wie beim Test Driven Development wird der
Test auch hier vor der Implementierung geschrieben. Bei dieser Art der
Software Entwicklung wird die API des zu entwickelnden Codes während
der Beschreibung und der Implementierung des Verhaltens in Form von
Tests erforscht.

\subsection{Rspec}

\textit{Rspec} ist ein Behaviour Driven Development Framework für
Ruby, das unter anderen auch von Dan North mitentwickelt wird. Es
implementiert eine domänenspezifische Sprache zu Beschreibung von
Anforderungen und Verhalten in Ruby. Als Beispiel für Behaviour Driven
Development mit Rspec soll hier die Berechnung der Distanz zwischen
zwei geographischen Positionen dienen. Hierfür soll eine Ruby Klasse
implementiert werden, die durch Anwendung der Haversine Formel
\cite{wiki:haversine} die Distanz in Kilometern berechnet. asasasas

Bevor man die Klasse implementiert, beschreibt man deren Verhalten
anhand von Beispielen. Diese Beispiele sollten im Idealfall von
Programmierer und demjenigen, der die Anforderungen der Anwendung
definiert erstellt werden. Die Beschreibung und Beispiele der
Haversine Klasse

Die Haversine Klasse
\begin{itemize}
\item berechnet eine Distanz von 878.01 km zwischen Berlin und Paris
\item berechnet eine Distanz von 878.01 km zwischen Paris und Berlin
\end{itemize}

Eine Beschreibung der
Haversine Klasse könnte wie folgt aussehen:

In der Praxis formuliert man diese Beschreibung gleich in der von
Rspec zur Verfügung gestellten domänen\-spezifischen Sprache.

{\small
\begin{verbatim}
describe Haversine do

  before(:each) do
    @berlin = Burningswell::Location.make_unsaved(:berlin)
    @paris  = Burningswell::Location.make_unsaved(:paris)
  end

  it "should calculate a distance of 0 km between the same location"
  it "should calculate a distance of 878.01 km between Berlin and Paris"
  it "should calculate a distance of 878.01 km between Paris and Berlin"

end
\end{verbatim}
}

{\small
\begin{verbatim}
describe Haversine do

  before(:each) do
    @berlin = Burningswell::Location.make_unsaved(:berlin)
    @paris  = Burningswell::Location.make_unsaved(:paris)
  end

  it "should calculate a distance of 0 km between the same location" do
    Haversine.distance(@berlin, @berlin).should == 0.km
  end

  it "should calculate a distance of 878.01 km between Berlin and Paris" do
    Haversine.distance(@berlin, @paris).should == 878.006710357836.km
  end

  it "should calculate a distance of 878.01 km between Paris and Berlin" do
    Haversine.distance(@paris, @berlin).should == 878.006710357836.km
  end

end
\end{verbatim}
}

Die Ruby Implementierung ist aus der Javascript Version
\cite{movable_type_scripts} von Chris Veness abgeleitet.

{\small
\begin{verbatim}
class Haversine

  cattr_accessor :earth_radius
  @@earth_radius = Burningswell::Mapping::EARTH_RADIUS

  attr_reader :from, :to

  def initialize(from, to, options = { })
    @from = Burningswell::Location.normalize(from)
    @to   = Burningswell::Location.normalize(to)
    @options = options
  end

  def distance
    @distance ||= calculate
  end

  def earth_radius
    @options[:earth_radius] || self.class.earth_radius
  end

  protected

  def calculate

    latitude  = (from.latitude.to_f  - to.latitude.to_f).to_radian
    longitude = (from.longitude.to_f - to.longitude.to_f).to_radian

    a = Math.sin(latitude / 2) * Math.sin(latitude / 2) +
        Math.cos(from.latitude.to_f.to_radian) *
        Math.cos(to.latitude.to_f.to_radian) *
        Math.sin(longitude / 2) * Math.sin(longitude / 2)

    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

    earth_radius * c

  end

  def self.distance(from, to, options = { })
    new(from, to, options).distance
  end

end
\end{verbatim}
}


{\small
\begin{verbatim}
The Haversine class
- should calculate a distance of 0 km between the same location
- should calculate a distance of 878.01 km between Berlin and Paris
- should calculate a distance of 878.01 km between Paris and Berlin
\end{verbatim}
}

Das \textit{Spec::Rails} Plugin bietet die nötige Infrastruktur für
Ruby on Rails Projekte. An die MVC-Architektur von Rails angelehnt
werden verschiedene Umgebungen um Model, View, Controller und Helper
zu spezifizieren bereitgestellt.

\subsection{Cucumber}

\textit{Cucumber} bietet Software Entwicklern die Möglichkeit das
Verhalten ihrer Anwendung in reinem Text zu beschreiben.

\section{Architektur der Web Applikation}
\section{Caching Verfahren in Ruby on Rails}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../community-plattform"
%%% End:
