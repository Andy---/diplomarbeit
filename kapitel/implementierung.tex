\chapter{Implementierung der Web Applikation}

\section{Vorstellung der verwendeten Technologien}

\subsection{Web Application Framework}

Ein \textit{Web Application Framework} ist eine Software Bibliothek
zur Entwicklung von dynamische Webseiten bzw. Web Applikationen. Ein
solches Framework baut meist auf der \textit{Model View Controller
  (MVC)} Architektur auf, deren Ziel es ist ein Software System in
einzelne, möglichst voneinander unabhängige Komponenten
aufzuteilen. Dadurch soll die Komplexität der Software reduziert
werden und die Erweiterung und Wiederverwendung des Programmcodes
erleichtert werden.

\subsection{Datenbank Management System}

In Web Applikationen wird für Anfragen an Daten und deren persistente
Speicherung meist ein \textit{objekt-relationaler Mapper (ORM)}
verwendet. Dieser ist dafür zuständig in einer Programmiersprache
verwendete Objekte auf das Schema einer relationalen Datenbank
abzubilden. Dadurch können Daten persistent gespeichert und später
wieder angefragt werden. In Ruby on Rails Anwendungen kommt hier
meistens das \textit{ActiveRecord} Framework zum Einsatz, das die
meisten der gängigen Datenbank Management Systeme (DMBS) unterstützt.

Bei der Auswahl des für die Web Applikation verwendeten Datenbank
Management Systems kamen kommerzielle Produkte wie Oracle's 11g oder
DB2 von IBM aus Kostengründen nicht in Frage. Insbesondere die
integrierten Möglichkeiten zur Auswertung von großen Datenbeständen
\footnote{hier die Historie der Vorhersagedaten und deren
  Klassifikation durch Benutzer} mit Data Mining Verfahren wären bei
diesen Produkten eine interessante Anwendung. Jedoch sind diese
Optionen in den kostenlosen Varianten dieser Produkte leider nur
eingeschränkt oder überhaupt nicht nutzbar.

Bei den Open Source Datenbank Management Systemen viel die Auswahl auf
\textit{PostgreSQL, ''the world's most advanced open source
  database''}. Zum einen wurden schon in der dieser Diplomarbeit
vorausgegangenen Studienarbeit gute und tiefgründige Erfahrungen mit
diesem DBMS gesammelt, zum anderen wird die Funktionalität von
PostgreSQL selbst und einiger der zur Verfügung stehenden
Erweiterungen den benötigten Anforderungen gerecht. Einige dieser
Anforderungen sollen hier beschrieben werden.

\begin{itemize}
\item Ein sogenannter \textit{Bulk Loader} wird benötigt um größere
  Datenmengen zu exportieren bzw. zu importieren. PostgreSQL bietet
  hierfür die \textit{COPY FROM/TO} Befehle, mit denen Dateien in
  verschiedenen Formaten sehr viel schneller als mit den sonst
  üblichen \textit{SELECT}, \textit{INSERT} und \textit{UPDATE}
  Befehlen verarbeitet werden können. Diese Funktionalität wird unter
  anderem für die Vorhersagedaten verarbeitenden ELT Prozesse
  benötigt.

\item Das \textit{PostGIS} Projekt erweitert PostgreSQL mit
  geografischen Funktionen und Datentypen, die konform zu der
  \textit{Simple Features Specification for SQL} des \textit{Open
    Geospatial Consortium} sind. Hiermit können geografische Objekte
  in dem weit verbreiteten \textit{Shapefile} Format verarbeitet
  werden. Insbesonder mit Hinblick auf die Integration von
  \textit{Google Maps} bieten sich hier einige interessante
  Anwendungen.

\item Aufbauend auf dem PostGIS Projekt stellt das \textit{pgRouting}
  Funktionalitäten zur Routenplanung bereit. In das DMBS integrierte
  \textit{Shortest Path} Algorithmen wie \textit{Dijkstra},
  \textit{Shooting Star} und \textit{Traveling Sales Person} können so
  effizient ausgeführt werden. Der Dijkstra Algorithmus wird
  beispielsweise in der Web Applikation dazu verwendet, die aus vielen
  anderen Community Plattformen bekannten Freundschaftsbeziehungen
  zwischen Benutzern zu berechnen.

\end{itemize}

\section{Architektur der Web Applikation}

\section{Behaviour \& Test Driven Development}

\textit{Behaviour Driven Development} ist eine Erweiterung des
\textit{Test Driven Development}, einer Methode aus dem Bereich der
\textit{Agilen Softwareentwicklung}. Ziel der Agilen
Softwareentwicklung ist es den klassischen Softwareentwicklungsprozess
schlanker und flexibler zu gestalten und sich mehr auf die zu
erreichenden Ziele und Anforderungen zu
fokussieren. Paarprogrammierung, ständige Refaktorisierung des Codes
und testgetriebene Entwicklung sind einige der dabei verwendeten
Methoden \cite{wiki:agile}.

Behaviour Driven Development ist ein durch Dan North geprägter Begriff
und eine Erweiterung der Philosophie des Test Driven Developments
\cite{wiki:bdd}. Durch die Einführung eines gemeinsamen Vokabulars
soll die Zusammenarbeit zwischen Programmieren und nicht-technischen
Beteiligten an einem Softwareprojekt erhöht werden. Das gemeinsame
Vokabular wird benutzt um das Verhalten, bzw. die Anforderungen der
Software gemeinsam zu beschreiben und eine Spezifikation zu erstellen.

Diese Spezifikation wird in Form von automatischen Tests in einer
domänen\-spezifische Sprache vom Programmierer implementiert.

\subsection{Red, Green, Refactor}

Die Entwicklung der Software erfolgt, wie beim Test Driven
Development, durch ständige Wiederholung des \textit{Red, Green,
  Refactor} Zykluses. \textit{Red} und \textit{Green} stehen für
fehlschlagende bzw. erfolgreiche Testfälle, und \textit{Refactor} für
die Umstrukturierung, Verbesserung und Säuberung schon implementierten
Programmcodes. Die Entwicklung der Anwendung wird in kleinere Teile,
sogenannte \textit{Feature} aufgeteilt und diese nacheinander
abgearbeitet. Das Verhalten eines zu implementierenden Features wird
durch mehrere Testfälle beschrieben und somit spezifiziert. Dabei
werden die folgenden drei Schritte solange wiederholt bis das
gewünschte Feature ausreichend spezifiziert und implementiert ist. Die
Kunst ist hierbei, immer nur sehr kleine Schritte pro Zyklus zu
spezifizieren und zu implementieren.

\subsubsection{Red - Die Spezifikation des Verhaltens}

In der \textit{Red} Phase wird ein korrekter, aber fehlschlagender,
Test geschrieben, der ein bestimmtes Verhalten eines noch nicht
implementiertes Features spezifiziert. Dieser Test sollte nur einen
sehr geringen Teil des gesamten Features
verifizieren. Beispielsweise, dass eine Methode ein Array zurück gibt,
die Elemente eines Arrays Instanzen einer bestimmten Klasse sind oder
die Distanz zwischen zwei gegebenen geografischen Positionen korrekt
berechnet wird.

\subsubsection{Green - Die Implementierung des Verhaltens}

Ziel der \textit{Green} Phase ist es den soeben geschriebenen und
fehlschlagenden Test (und alle bisher erfolgreichen) durch eine
geeignete Implementierung zum Erfolg zu bringen. Hierbei ist zu
Erwähnen, dass auch eine vorübergehend nicht korrekte Implementierung
erlaubt ist, solange alle Tests erfolgreich sind. Beispielsweise kann
eine Methode vorübergehend immer einen leeren Array zurückgegeben,
wenn im Test nur auf die Rückgabe eines Arrays geprüft wird. Diese
inkorrekten Implementierungen sind gewollte Indizien für die als
nächstes zu spezifizierenden Testfälle. In einem der nächsten Zyklen
wird die inkorrekte Implementierung durch einen neuen fehlschlagenden
Test aufgedeckt und durch eine korrekte Implementierung ausgetauscht.

\subsubsection{Refactor - Besserer Programmcode durch
  Umstrukturierung}

Die \textit{Refactor} Phase dient dazu, bisher entwickelten
Programmcode durch Umstrukturierung aufzuräumen. Dazu zählt die
Eliminierung doppelten oder ähnlichen Codes, das Extrahieren von
Hilfsmethoden und weiterer Refactor-Techniken, die ausführlich in
\cite{fowler99refactoring} beschrieben werden. Insbesondere in
Software Projekten, die ohne automatische Tests entwickelt werden, ist
diese Phase hoch problematisch. Zuvor funktionierender und durch
Refactoring geänderter Programmcode muss nochmals manuell verifiziert
werden. Probleme treten oft auch an nicht offensichtlich mit den
Änderungen in Verbindung stehenden Teilen des Programms auf. Ein
deshalb notwendiger, manueller Systemtest kann dann oft zu aufwendig
sein, dass die Vorteile des Refactoring in den Hintergrund rücken und
oftmals darauf verzichtet wird.  \textit{''Never change a running
  system''. \footnote{Oft falsch verwendeter Pseudoanglizismus}}

\subsection{Vorteile Behaviour \& Test Driven Developments}

Diese Art der Softwareentwicklung wird heute oft immer noch aus den
verschiedensten Gründen abgelehnt. \textit{''Nicht notwendig, bei gut
  entwickeltem Code''}, \textit{''zu aufwendig''}, oder Barrieren,
seine gewohnte Arbeitsweise zu ändern, sind einige dieser Gründe. Der
Klassiker \textit{''man würde ja, aber habe keine Zeit Tests zu
  schreiben''} zeigt, dass die Vorteile des Test Driven Development
oft nicht erkannt werden. Dies liegt unter anderem wohl daran, dass es
einige Zeit in Anspruch nimmt seine gewohnte Arbeitsweise zu ändern,
und die Früchte erst nach einiger Zeit und Praxis deutlich zu sehen
sind. Einige der Vorteile sollen im folgenden deutlich gemacht werden.

\subsubsection{Steigerung der eigenen Produktivität}

Martin Fowler beschreibt in \cite{fowler99refactoring}[S.89], dass
viele Programmierer ihre Zeit nicht mit der Entwicklung des
eigentlichen Programmcodes verbringen. Ein Großteil der Zeit wird für
Debugging und das manuelle Testen des gerade zu entwickelten Codes
verwendet. Produziert wird hier nur der eigentliche Programmcode. Beim
Test Driven Development wird diese Zeit für die selben Ziele
verwendet, doch als Nebenprodukt entstehen automatische
Tests. Manuelles Testen und Debugging muss unter Umständen immer
wieder von neuem wiederholt werden, während automatische Tests
sicherstellen, dass bestimmte Dinge funktionieren und nicht nochmals
verifiziert werden müssen. Die Entwicklung von Tests bedeutet mehr
Code, was mit mehr Arbeit gleichzusetzen ist. Dieser Mehraufwand
scheint auf den ersten Blick keinen Sinn zu machen, bis man selbst
erfahren hat wie sehr dieses Vorgehen die eigene Produktivität
steigern kann.

\subsubsection{Besserer Programmcode}

Schreibt man Tests vor der eigentlichen Implementierung blickt man von
vornherein aus der Rolle eines Anwenders auf die zu entwickelnde
Schnittstelle. Die API des zu implementierenden Codes kann so während
der Entwicklung der Testfälle ''erforscht'' werden. Die Struktur des
Programmcodes wird zudem positiv beeinflusst, da vor der
Implementierung überlegt werden muss wie das Verhalten am besten
getestet werden kann. Implementierungen, die vor Testfällen entwickelt
wurden, müssen oft umstrukturiert werden damit diese überhaupt
getestet werden können. Zu lange Methoden sind hier das klassische
Beispiel. Sie lassen sich schlecht testen weil sie oft viel zu viel
auf einmal erledigen. Darüber hinaus sind sie meist auch noch schwer
zu verstehen. Durch Extraktion von Hilfsmethoden kann man diese
Methoden verkürzen und verbessert dadurch die Lesbarkeit des
Codes. Die extrahierten Methoden und die verkürzte Methode selbst
lassen sich nun in Isolation meist viel besser und einfacher testen
als zuvor. Zudem können die extrahierten Hilfsmethoden potentiell von
anderem Programmcode mitverwendet werden.

\subsubsection{Qualitätsmanagment und Teamwork}

Insbesondere bei Softwareprojekten in dynamischen Programmiersprachen,
die erst zur Laufzeit interpretiert werden und keine statische
Typprüfung besitzen ist es von großem Vorteil eine automatische
Testsuite zu haben. In diesen Sprachen gibt es keinen Compiler der
nach Änderungen überprüfen kann, dass zumindest syntaktisch noch alles
korrekt ist. Änderungen an einer Stelle im System haben oft
Konsequenzen an anderen nicht vorhersehbaren Stellen. Eine Testsuite,
welche die gesamte Codebasis abdeckt kann sicherstellen, dass
Änderungen funktionieren und eingeschlichene Fehler so früh wie
möglich aufgedeckt werden.

Auch bei Softwareprojekten, die von mehreren Personen gleichzeitig
entwickelt werden bietet eine Testsuite Schutz gegen das Einschleichen
von Fehlern und hilft bei der Weiterentwicklung fremden Codes. Wird
Programmcode vom nicht ursprünglichen Autor geändert oder erweitert
muss dieser zuerst verstanden, erweitert und danach verifiziert
werden. Testfällen dienen dabei nicht nur zur Verifizierung dieser
Änderungen, sondern auch als Dokumentation und Spezifikation, und
helfen somit das Problem besser und schneller zu verstehen.

\subsection{Unit Tests mit RSpec}

\textit{RSpec} \cite{rspec} ist ein Behaviour Driven Development
Framework für die Entwicklung von Softwareprojekten in der
Programmiersprache Ruby.  Es implementiert eine interne
bzw. eingebettete domänen\-spezifische Sprache (DSL) zur Spezifikation
von Anforderungen in Form von Unit Tests.  Spezifikationen können wie
bei den diversen xUnit Derivaten gruppiert, verifiziert und deren
Resultate angezeigt werden. Als Beispiel soll hier die Implementierung
einer Klasse dienen, welche die Distanz in Kilometern zwischen zwei
geografischen Positionen berechnet. Vor der eigentlichen
Implementierung wird das Verhalten der Klasse anhand von Beispielen in
der RSpec DSL wie folgt spezifiziert:

{\footnotesize
\begin{verbatim}
describe Haversine do
  it "should calculate a distance of 0 km between the same location"
  it "should calculate a distance of 878.01 km between Berlin and Paris"
end
\end{verbatim}
}

Diese Spezifikation der Haversine Klasse ist Teil des oben erwähnten
gemeinsamen Vokabulars und zugleich gültiger und ausführbarer Ruby
Code. Die Entwicklung einer einfachen, verständlichen und
aussagekräftigen DSL hatte zum Ziel, dass Spezifikationen wie diese
von oder mit nicht-technischen Personen erstellt werden können. Die
eigentliche Verifizierung und Implementierung des Verhaltens soll dann
vom Programmierer erstellt werden. Bevor die Haversine Formel durch
eine Klasse implementiert wird, erweitert der Programmierer die
Spezifikation durch Code, der das Verhalten der Klasse verifiziert. Da
die Spezifikation in der Programmiersprache Ruby geschrieben ist, kann
diese vom Programmierer einfach und flexibel erweitert werden. Auch
hier kommen Konstrukte der RSpec DSL zum Einsatz, welche die
Lesbarkeit vereinfachen und die Spezifikation verständlicher machen
sollen.

{\footnotesize
\begin{verbatim}
describe Haversine do

  before(:each) do
    @berlin, @paris = Location.make(:berlin), Location.make(:paris)
  end

  it "should calculate a distance of 0 km between the same location" do
    Haversine.distance(@berlin, @berlin).should == 0.km
  end

  it "should calculate a distance of 878.01 km between Berlin and Paris" do
    Haversine.distance(@berlin, @paris).should == 878.006710357836.km
  end

end
\end{verbatim}
}

Das Ausführen dieser Spezifikation schlägt auf Grund der noch
fehlenden Implementierung fehl. Durch die Wiederholung des Red, Green,
Refactor Zykluses wird nun das Verhalten der Klasse implementiert. Der
erste Testfall kann durch die folgende, noch inkorrekte
Implementierung zum Erfolg gebracht werden:

{\footnotesize
\begin{verbatim}
class Haversine

  def self.distance(from, to, options = { })
    return 0 # A first, naive implementation.
  end

end
\end{verbatim}
}

Im nächsten Iterationszyklus muß nun die eigentliche Haversine Formel
\cite{wiki:haversine} implementiert werden um auch den zweiten
Testfall zum Erfolg zu bringen. Durch das Aufteilen der zu
bewältigenden Aufgaben in kleine Iterationszyklen wird das
spezifizierte Verhalten so Schritt für Schritt implementiert. Die
nächste zu bearbeitende Teilaufgabe wird durch einen neuen Testfall
beschrieben und das bisher erwartete Verhalten durch die bestehenden
verifiziert.

Das im Umfeld von RSpec entwickelte \textit{Spec::Rails} Plugin bietet
die nötige Infrastruktur für Ruby on Rails Projekte. An die
MVC-Architektur von Rails angelehnt werden verschiedene Umgebungen und
Hilfsmethoden bereit gestellt um Model, View, Controller und Helper zu
spezifizieren. Während der Entwicklung des Prototypen der Web
Applikation wurden insgesamt 4274 Testfälle spezifiziert, die 92.6\%
(C0 Code Coverage) des gesamten Codes abdecken und das korrekte
Verhalten der Web Applikation verifizieren.

Das Durchlaufen der gesamten Testsuite benötigt momentan ca. 15
Minuten, was zu einem Durchschnitt von 4,8 Sekunden pro Test
führt. Diese hohe Laufzeit lässt sich auf die vielen Datenbankzugriffe
zurückführen, die vor den meisten Testfällen einen bestimmten
Datenbestand herstellen und danach wieder zurücksetzen müssen. Durch
den Einsatz von \textit{Mocks} und \textit{Stubs} können diese
Datenbankzugriffe reduziert werden. Diese Techniken sollten jedoch
vorsichtig eingesetzt werden. Eine übermäßige Anwendung resultiert
meist in einer zu engen Kopplung zwischen Test und
Implementierung. Diese Kopplung macht sich dann meist beim Refactoring
bemerkbar, wenn Tests ebenfalls geändert werden müssen weil aus
Performanzgründen Annahmen über die Implementierung getroffen
wurden. Hier muss man einen Mittelweg zwischen der Wartbarkeit der
Testsuite und deren Laufzeit finden.

In der Praxis hat sich herausgestellt, dass der Durchschnittswert von
4,8 Sekunden pro Test von geringer Bedeutung ist. Bei der
Implementierung eines Features lässt man meist nur die gerade
aktuellen Testfälle laufen und deren Laufzeit ist im einzelnen meist
besser als der erwähnte Durchschnittswert. Mindestens vor jedem
Deployment sollte dann die gesamte Testsuite ausgeführt werden um
sicherzustellen, dass das System auch in der Gesamtheit korrekt
funktioniert.

\subsection{Integrationstests mit Cucumber}

\textit{Cucumber} \cite{cucumber} ist ein weiteres Framework für
Behaviour Driven Development in Ruby. Es bietet die Möglichkeit das
Verhalten von Anwendungen in einer \textit{natürlichen Sprache}, wie
z.B. Englisch oder Deutsch, zu beschreiben. Auch hier war das Ziel,
das nicht-technische Personen das Verhalten einer Anwendung durch ein
gemeinsam verwendetes Vokabular beschreiben und spezifizieren können.
Die Spezifikationen wird dann von einem Entwickler erweitert um daraus
automatische Tests zu erstellen. In Ruby on Rails Projekten wird
Cucumber üblicherweise benutzt um durch Integrationstests
sicherzustellen, dass das Zusammenspiel zwischen Browser und
Controllern funktioniert.

Ein Feature wird in Cucumber's externer DSL \textit{Gherkin}
\footnote{\url{http://wiki.github.com/aslakhellesoy/cucumber/gherkin}}
beschrieben, einer sogenannten \textit{Business Readable, Domain
  Specific Language}.
\footnote{\url{http://martinfowler.com/bliki/BusinessReadableDSL.html}}
Die Beschreibung kann in einer der über 30 unterstützen natürlichen
Sprachen verfasst werden, wobei nur eine durch Gherkin definierte
Struktur eingehalten werden muss. Als Beispiel für solch eine
Spezifikation soll hier die Authentifizierung eines Benutzers durch
die Web Applikation dienen.

{\footnotesize
\begin{verbatim}
Feature: Authentication
  To ensure the safety of the application
  A user of the system
  Must authenticate before using the application

  Scenario: Login as an activated user with wrong credentials
    Given I am an activated user
     When I log in with invalid credentials
     Then I should see "Sorry, invalid nick/password combination given."
      And I should not be logged in
\end{verbatim}
}

Die Struktur der Beschreibung ist durch die Reihenfolge einiger
Schlüssel\-wörter vorgegeben. Mit dem Schlüsselwort \textit{Feature}
wird die Spezifikation eines Features eingeleitet, gefolgt von einer
kurzen Beschreibung zu Dokumentationszwecken. Ein Abschnitt, der mit
dem Schlüsselwort \textit{Scenario} definiert wird, beschreibt das
Verhalten der Anwendung in einer bestimmten Situation. Mit dem
Schlüsselwort \textit{Given} beschreibt man welche Vorbedingungen in
der gegebenen Situation herrschen müssen. \textit{When} beschreibt
auszuführende Aktionen, wie z.B. das Ausfüllen eines Formulars oder
das Klicken eines Links. Das Schlüsselwort \textit{Then} beschreibt
denn Zustand nach dem ausführen der Aktionen. Mit \textit{And} wird
eine weitere Zeile des selben Typs der vorigen Zeile definiert, und
dient zur Verknüpfung und der besseren Lesbarkeit.

Cucumber verarbeitet solch eine Spezifikation zeilenweise und führt
für bestimmte Zeilen Code aus der die beschriebenen Vorbedingungen
herstellt, Aktionen ausführt und Erwartungen verifiziert. Für jede
Zeile, die mit einem der Schlüsselwörter \textit{Given},
\textit{When}, \textit{Then} oder \textit{And} anfängt, muss ein auf
sie passender regulärer Ausdruck definiert werden, der mit einem
Codeblock assoziiert wird.

Der folgende Programmcode definiert einen regulären Ausdruck der auf
die erste \textit{Given} Zeile passt. Der mit ihm assoziierte Codeblock
erstellt einen neuen und aktivierten Benutzer, speichert ihn in der
Datenbank und weist ihn einer Variablen zu, auf die in anderen
Codeblöcken zugegriffen werden kann.

{\footnotesize
\begin{verbatim}
Given /^I am an activated user$/ do
  @current_user = User.make(:activated)
end
\end{verbatim}
}

Cucumber stellt eine Bibliothek einiger dieser häufige verwendeten
Konstrukte als Makros zu Verfügung. Diese können in eigenen
Codeblöcken benutzt werden. Der folgende Code verwendet einige dieser
vordefinierten Konstrukte. Der Code der dabei ausgeführt wird
simuliert das Besuchen der \textit{Login} Seite, das Ausfüllen zweier
Textfelder mit dem Benutzernamen und einem falschen Passwort, sowie
das Klicken des \textit{Login} Buttons mit einem Browser.

{\footnotesize
\begin{verbatim}
When /^I log in with invalid credentials$/ do
  Given "I am on the login page"
  When  "I fill in \"login\" with \"#{@current_user.nick}\""
  When  "I fill in \"password\" with \"invalid-password\""
  When  "I press \"Login\""
end
\end{verbatim}
}

Die Zeile \textit{Then I should see ''Sorry, invalid nick/password
  combination given.''} verwendet ebenfalls ein von Cucumber
definiertes Makro, dass überprüft ob der in Hochkomma gesetzte Text in
der vom Server empfangenen HTML Seite zu finden ist.

Die letzte Zeile ist ein selbst definiertes Makro, das wiederum
Methoden des RSpec Frameworks verwendet um zu überprüfen dass der
Benutzer nicht angemeldet ist.

{\footnotesize
\begin{verbatim}
Then /^I should not be logged in$/ do
  controller.send(:current_user).should be_nil
end
\end{verbatim}
}

Cucumber bietet die Möglichkeit eigene Makros interaktiv zu
entwickeln. Für Zeilen die keinem regulären Ausdruck zugeordnet werden
können, generiert Cucumber auf sie passende Codeblöcke, die sehr
einfach angepasst und weiterentwickelt werden können. Durch die
Verwendung der eigenen und der vielen vordefinierten Makros lässt sich
so ein auf die eigene Domäne zugeschnittenes Vokabular definieren, mit
dem das korrekte Verhalten einer Anwendung auf einem hohem
Abstraktionsniveau verifiziert werden kann.

Da Cucumber relativ neu ist wurden im hier entwickelten Prototypen
bisher nur 17 solcher Szenarien spezifiziert, die vor allem die
korrekte Interaktion mit externen Diensten
verifizieren. Beispielsweise werden von Benutzern publizierte Videos
und Bilder von der Web Applikation auf \textit{Amazon's
  S3}\footnote{Amazon Simple Storage Service
  \url{http://aws.amazon.com/s3}} gespeichert. Die Verwendung dieses
Web Services wurde aus Performanzgründen in den RSpec Unit Tests durch
Mock Objekte ersetzt. Integrationstests mit Cucumber bieten hier eine
gute Möglichkeit das Zusammenspiel von Browser und Controllern in
einer realitätsnahen Umgebung zu verifizieren.

\section{Caching Verfahren in Ruby on Rails}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../community-plattform"
%%% End:
